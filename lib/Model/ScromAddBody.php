<?php
/**
 * ScromAddBody
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * LtiSaas API
 *
 * <p>A brief overview of the API versions:</p> <ul> <li><strong>v0:</strong> This version is solely for testing and does not interact with the database, nor does it involve any validation. It simply serves mock data.</li> <li><strong>v1:</strong> This is the official version of the LtiSaas API, intended for production use.</li> </ul> <p>Please be informed that when testing version v0, the HTTP <code>Access-Token</code> header should be set with the value 'dummy'.</p> <p>Also, please note that the API has a limit of 2500 results per response.</p> <p>Additionally, all webservices support both POST and GET requests. However, the POST method is required when uploading files.</p>
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.46
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * ScromAddBody Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ScromAddBody implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'scrom_add_body';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'courseid' => 'int',
        'packagefile' => 'string',
        'name' => 'string',
        'popup' => 'int',
        'width' => 'int',
        'height' => 'int',
        'grademethod' => 'int',
        'maxgrade' => 'int',
        'maxattempt' => 'int',
        'whatgrade' => 'int',
        'forcenewattempt' => 'int',
        'lastattemptlock' => 'int',
        'autocommit' => 'int',
        'masteryoverride' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'courseid' => null,
        'packagefile' => 'binary',
        'name' => null,
        'popup' => null,
        'width' => null,
        'height' => null,
        'grademethod' => null,
        'maxgrade' => null,
        'maxattempt' => null,
        'whatgrade' => null,
        'forcenewattempt' => null,
        'lastattemptlock' => null,
        'autocommit' => null,
        'masteryoverride' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'courseid' => 'courseid',
        'packagefile' => 'packagefile',
        'name' => 'name',
        'popup' => 'popup',
        'width' => 'width',
        'height' => 'height',
        'grademethod' => 'grademethod',
        'maxgrade' => 'maxgrade',
        'maxattempt' => 'maxattempt',
        'whatgrade' => 'whatgrade',
        'forcenewattempt' => 'forcenewattempt',
        'lastattemptlock' => 'lastattemptlock',
        'autocommit' => 'autocommit',
        'masteryoverride' => 'masteryoverride'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'courseid' => 'setCourseid',
        'packagefile' => 'setPackagefile',
        'name' => 'setName',
        'popup' => 'setPopup',
        'width' => 'setWidth',
        'height' => 'setHeight',
        'grademethod' => 'setGrademethod',
        'maxgrade' => 'setMaxgrade',
        'maxattempt' => 'setMaxattempt',
        'whatgrade' => 'setWhatgrade',
        'forcenewattempt' => 'setForcenewattempt',
        'lastattemptlock' => 'setLastattemptlock',
        'autocommit' => 'setAutocommit',
        'masteryoverride' => 'setMasteryoverride'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'courseid' => 'getCourseid',
        'packagefile' => 'getPackagefile',
        'name' => 'getName',
        'popup' => 'getPopup',
        'width' => 'getWidth',
        'height' => 'getHeight',
        'grademethod' => 'getGrademethod',
        'maxgrade' => 'getMaxgrade',
        'maxattempt' => 'getMaxattempt',
        'whatgrade' => 'getWhatgrade',
        'forcenewattempt' => 'getForcenewattempt',
        'lastattemptlock' => 'getLastattemptlock',
        'autocommit' => 'getAutocommit',
        'masteryoverride' => 'getMasteryoverride'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const POPUP_0 = 0;
    const POPUP_1 = 1;
    const GRADEMETHOD_0 = 0;
    const GRADEMETHOD_1 = 1;
    const GRADEMETHOD_2 = 2;
    const GRADEMETHOD_3 = 3;
    const WHATGRADE_0 = 0;
    const WHATGRADE_1 = 1;
    const WHATGRADE_2 = 2;
    const FORCENEWATTEMPT_0 = 0;
    const FORCENEWATTEMPT_1 = 1;
    const FORCENEWATTEMPT_2 = 2;
    const LASTATTEMPTLOCK_0 = 0;
    const LASTATTEMPTLOCK_1 = 1;
    const AUTOCOMMIT_0 = 0;
    const AUTOCOMMIT_1 = 1;
    const MASTERYOVERRIDE_0 = 0;
    const MASTERYOVERRIDE_1 = 1;

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPopupAllowableValues()
    {
        return [
            self::POPUP_0,
            self::POPUP_1,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getGrademethodAllowableValues()
    {
        return [
            self::GRADEMETHOD_0,
            self::GRADEMETHOD_1,
            self::GRADEMETHOD_2,
            self::GRADEMETHOD_3,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getWhatgradeAllowableValues()
    {
        return [
            self::WHATGRADE_0,
            self::WHATGRADE_1,
            self::WHATGRADE_2,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getForcenewattemptAllowableValues()
    {
        return [
            self::FORCENEWATTEMPT_0,
            self::FORCENEWATTEMPT_1,
            self::FORCENEWATTEMPT_2,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLastattemptlockAllowableValues()
    {
        return [
            self::LASTATTEMPTLOCK_0,
            self::LASTATTEMPTLOCK_1,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAutocommitAllowableValues()
    {
        return [
            self::AUTOCOMMIT_0,
            self::AUTOCOMMIT_1,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMasteryoverrideAllowableValues()
    {
        return [
            self::MASTERYOVERRIDE_0
            self::MASTERYOVERRIDE_1
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['courseid'] = isset($data['courseid']) ? $data['courseid'] : null;
        $this->container['packagefile'] = isset($data['packagefile']) ? $data['packagefile'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['popup'] = isset($data['popup']) ? $data['popup'] : null;
        $this->container['width'] = isset($data['width']) ? $data['width'] : null;
        $this->container['height'] = isset($data['height']) ? $data['height'] : null;
        $this->container['grademethod'] = isset($data['grademethod']) ? $data['grademethod'] : null;
        $this->container['maxgrade'] = isset($data['maxgrade']) ? $data['maxgrade'] : null;
        $this->container['maxattempt'] = isset($data['maxattempt']) ? $data['maxattempt'] : null;
        $this->container['whatgrade'] = isset($data['whatgrade']) ? $data['whatgrade'] : null;
        $this->container['forcenewattempt'] = isset($data['forcenewattempt']) ? $data['forcenewattempt'] : null;
        $this->container['lastattemptlock'] = isset($data['lastattemptlock']) ? $data['lastattemptlock'] : null;
        $this->container['autocommit'] = isset($data['autocommit']) ? $data['autocommit'] : null;
        $this->container['masteryoverride'] = isset($data['masteryoverride']) ? $data['masteryoverride'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['courseid'] === null) {
            $invalidProperties[] = "'courseid' can't be null";
        }
        if ($this->container['packagefile'] === null) {
            $invalidProperties[] = "'packagefile' can't be null";
        }
        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        $allowedValues = $this->getPopupAllowableValues();
        if (!is_null($this->container['popup']) && !in_array($this->container['popup'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'popup', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getGrademethodAllowableValues();
        if (!is_null($this->container['grademethod']) && !in_array($this->container['grademethod'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'grademethod', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getWhatgradeAllowableValues();
        if (!is_null($this->container['whatgrade']) && !in_array($this->container['whatgrade'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'whatgrade', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getForcenewattemptAllowableValues();
        if (!is_null($this->container['forcenewattempt']) && !in_array($this->container['forcenewattempt'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'forcenewattempt', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLastattemptlockAllowableValues();
        if (!is_null($this->container['lastattemptlock']) && !in_array($this->container['lastattemptlock'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'lastattemptlock', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAutocommitAllowableValues();
        if (!is_null($this->container['autocommit']) && !in_array($this->container['autocommit'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'autocommit', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getMasteryoverrideAllowableValues();
        if (!is_null($this->container['masteryoverride']) && !in_array($this->container['masteryoverride'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'masteryoverride', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets courseid
     *
     * @return int
     */
    public function getCourseid()
    {
        return $this->container['courseid'];
    }

    /**
     * Sets courseid
     *
     * @param int $courseid The unique identifier of the course
     *
     * @return $this
     */
    public function setCourseid($courseid)
    {
        $this->container['courseid'] = $courseid;

        return $this;
    }

    /**
     * Gets packagefile
     *
     * @return string
     */
    public function getPackagefile()
    {
        return $this->container['packagefile'];
    }

    /**
     * Sets packagefile
     *
     * @param string $packagefile The .zip file of the SCORM package
     *
     * @return $this
     */
    public function setPackagefile($packagefile)
    {
        $this->container['packagefile'] = $packagefile;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name of the SCORM package
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets popup
     *
     * @return int
     */
    public function getPopup()
    {
        return $this->container['popup'];
    }

    /**
     * Sets popup
     *
     * @param int $popup Indicates if the SCORM package should open in a new window (1) or not (0)
     *
     * @return $this
     */
    public function setPopup($popup)
    {
        $allowedValues = $this->getPopupAllowableValues();
        if (!is_null($popup) && !in_array($popup, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'popup', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['popup'] = $popup;

        return $this;
    }

    /**
     * Gets width
     *
     * @return int
     */
    public function getWidth()
    {
        return $this->container['width'];
    }

    /**
     * Sets width
     *
     * @param int $width The display width for the SCORM package
     *
     * @return $this
     */
    public function setWidth($width)
    {
        $this->container['width'] = $width;

        return $this;
    }

    /**
     * Gets height
     *
     * @return int
     */
    public function getHeight()
    {
        return $this->container['height'];
    }

    /**
     * Sets height
     *
     * @param int $height The display height for the SCORM package
     *
     * @return $this
     */
    public function setHeight($height)
    {
        $this->container['height'] = $height;

        return $this;
    }

    /**
     * Gets grademethod
     *
     * @return int
     */
    public function getGrademethod()
    {
        return $this->container['grademethod'];
    }

    /**
     * Sets grademethod
     *
     * @param int $grademethod The grading method for the SCORM package (0: learning objects, 1: highest grade, 2: average      *                     grade, 3: sum grade)
     *
     * @return $this
     */
    public function setGrademethod($grademethod)
    {
        $allowedValues = $this->getGrademethodAllowableValues();
        if (!is_null($grademethod) && !in_array($grademethod, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'grademethod', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['grademethod'] = $grademethod;

        return $this;
    }

    /**
     * Gets maxgrade
     *
     * @return int
     */
    public function getMaxgrade()
    {
        return $this->container['maxgrade'];
    }

    /**
     * Sets maxgrade
     *
     * @param int $maxgrade The maximum grade possible for the SCORM package
     *
     * @return $this
     */
    public function setMaxgrade($maxgrade)
    {
        $this->container['maxgrade'] = $maxgrade;

        return $this;
    }

    /**
     * Gets maxattempt
     *
     * @return int
     */
    public function getMaxattempt()
    {
        return $this->container['maxattempt'];
    }

    /**
     * Sets maxattempt
     *
     * @param int $maxattempt The maximum number of attempts allowed for the SCORM package
     *
     * @return $this
     */
    public function setMaxattempt($maxattempt)
    {
        $this->container['maxattempt'] = $maxattempt;

        return $this;
    }

    /**
     * Gets whatgrade
     *
     * @return int
     */
    public function getWhatgrade()
    {
        return $this->container['whatgrade'];
    }

    /**
     * Sets whatgrade
     *
     * @param int $whatgrade The grading strategy for multiple attempts (0: highest attempt, 1: average grade, 2: first      *                     attempt)
     *
     * @return $this
     */
    public function setWhatgrade($whatgrade)
    {
        $allowedValues = $this->getWhatgradeAllowableValues();
        if (!is_null($whatgrade) && !in_array($whatgrade, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'whatgrade', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['whatgrade'] = $whatgrade;

        return $this;
    }

    /**
     * Gets forcenewattempt
     *
     * @return int
     */
    public function getForcenewattempt()
    {
        return $this->container['forcenewattempt'];
    }

    /**
     * Sets forcenewattempt
     *
     * @param int $forcenewattempt Policy for forcing new attempts (0: no, 1: every new attempt is a new grade, 2: every new      *                     attempt resets previous grades)
     *
     * @return $this
     */
    public function setForcenewattempt($forcenewattempt)
    {
        $allowedValues = $this->getForcenewattemptAllowableValues();
        if (!is_null($forcenewattempt) && !in_array($forcenewattempt, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'forcenewattempt', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['forcenewattempt'] = $forcenewattempt;

        return $this;
    }

    /**
     * Gets lastattemptlock
     *
     * @return int
     */
    public function getLastattemptlock()
    {
        return $this->container['lastattemptlock'];
    }

    /**
     * Sets lastattemptlock
     *
     * @param int $lastattemptlock Indicates if the SCORM package should be locked after the last attempt (0: no, 1: yes)
     *
     * @return $this
     */
    public function setLastattemptlock($lastattemptlock)
    {
        $allowedValues = $this->getLastattemptlockAllowableValues();
        if (!is_null($lastattemptlock) && !in_array($lastattemptlock, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'lastattemptlock', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['lastattemptlock'] = $lastattemptlock;

        return $this;
    }

    /**
     * Gets autocommit
     *
     * @return int
     */
    public function getAutocommit()
    {
        return $this->container['autocommit'];
    }

    /**
     * Sets autocommit
     *
     * @param int $autocommit Indicates if the SCORM package grades should auto commit (0: no, 1: yes)
     *
     * @return $this
     */
    public function setAutocommit($autocommit)
    {
        $allowedValues = $this->getAutocommitAllowableValues();
        if (!is_null($autocommit) && !in_array($autocommit, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'autocommit', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['autocommit'] = $autocommit;

        return $this;
    }

    /**
     * Gets masteryoverride
     *
     * @return int
     */
    public function getMasteryoverride()
    {
        return $this->container['masteryoverride'];
    }

    /**
     * Sets masteryoverride
     *
     * @param int $masteryoverride Indicates if the mastery grade overrides the max grade (0: no, 1: yes)
     *
     * @return $this
     */
    public function setMasteryoverride($masteryoverride)
    {
        $allowedValues = $this->getMasteryoverrideAllowableValues();
        if (!is_null($masteryoverride) && !in_array($masteryoverride, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'masteryoverride', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['masteryoverride'] = $masteryoverride;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
